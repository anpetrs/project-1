# **Шпаргалка: Создание и синхронизация локального и удалённого репозиториев**

**Git** — это

система контроля версий, которая помогает отслеживать изменения в проекте.  
Git позволяет сохранять изменения локально и при необходимости возвращаться к предыдущим версиям проекта. Также можно создать удалённую копию на хостинг-платформе, которая работает с Git, и поделиться результатом с другими.

---

# **Локальный репозиторий**

## **Создание и инициализация репозитория**

1. создайте папку *"Название_папки"* с помощью команды ```mkdir```.
2. перейдите в неё с помощью команды ```cd```.
3. выполните команду ```git init```.  

Ура! вы создали и инициализировали репозиторий.  
С помощью команды ```git status``` можно смотреть статус репозитория.  


«Разгитить» папку (т.е. удалить скрытую папку *.git*), если что-то пошло не так, можно с помощью команды ```rm -rf .git```, перейдя предварительно в папку с помощью команды ```cd```.  

## **Добавление файлов в репозиторий**

1. создайте в папке репозитория файлы с помощью команды ```touch```.
2. подготовьте к сохранению файлы с помощью команды:
- ```git add --all``` для всех файлов сразу,
- ```git add <*название файла*>``` для отдельного файла,
- ```git add .``` для текущей папки.
3. проверьте статус с помощью команды ```git status```, чтобы посмотреть, что изменилось.  

Готово! Файлы, которые отмечены зелёным, теперь отслеживаются и готовы к сохранению.  

### **Статусы файлов в Git**

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом:  

- новые файлы в Git-репозитории помечаются как ```untracked```, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду ```git add```.
- после выполнения команды ```git add``` файл попадает в *staging area*, то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии ```staged```.  **Команда ```git add``` добавляет в *staging area* только текущее содержимое файла.**  
  *Staging area также называют index или cache, а состояние файла staged иногда называют indexed или cached.*  
- cостояние ```tracked``` — это противоположность ```untracked```: в него попадают все файлы, в которых Git так или иначе отслеживает изменения.
- cостояние ```modified``` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.
  **Чтобы добавить в *staging* последнюю версию, нужно выполнить ```git add file.txt``` ещё раз.**

## **Сохранение состояния файлов в репозитории**

Сохранение, или фиксацию состояния файлов, называют **коммитом**. Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться». По аналогии с командой Ctrl+Z для целой папки (репозитория).  
1. перейдите в папку репозитория и создайте коммит с помощью следующей команды: ```$ git commit -m "текст-описание для коммита"```.
2. с помощью команды ```git commit``` выведите информацию о коммите.

### **Оформление сообщений к коммитам**

правильно оформленные сообщения коммитов:
- легко читаются;
- информативны;
- оформлены в одном стиле.

Для сообщений на русском языке часто рекомендуют использовать **инфинитивы**. Например: ```Добавить тесты для PipkaService, Исправить ошибку #123```.   
Для сообщений на английском рекомендуется использовать **повелительное наклонение**. Например: ```Use library mega_lib_300, Fix exit button```.

**СТИЛИ ОФОРМЛЕНИЯ**:
**1. Корпоративный**  
Во многих компаниях применяется Jira — система для организации проектов и задач. В начале сообщения обычно указывают ```Jira-ID```, а после — текст сообщения.  
**2. Conventional Commits**  
Подходит для репозиториев с исходным кодом программ и предлагает такой формат коммита: ```<type>: <сообщение>```. Первая часть *type* — это тип изменений.  
**3. GitHub-стиль**  
GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать ```#<номер задачи>```.  GitHub свяжет коммит и задачу.

### **Хеш — идентификатор коммита**

Git хеширует (преобразует) информацию о коммите с помощью алгоритма ```SHA-1``` *(от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования»)* и получает для каждого коммита свой уникальный **хеш** — результат хеширования.

**Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.**

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:
- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Все хеши, а также таблицу соответствий ```хеш → информация о коммите``` Git хранит в папке .git.

### **Лог полный и сокращённый** 

Лог (от англ. log — «журнал [записей]») хранит информацию о коммитах.
После вызова ```git log``` появляется список коммитов. 

Элементы, из которых состоит описание:
- строка из цифр и латинских букв после слова *commit* — это хеш коммита;
- *Author* — имя автора и его электронная почта;
- *Date* — дата и время создания коммита;
- в конце находится *сообщение коммита*.

Получить **сокращённый лог** можно с помощью команды ```git log --oneline```.
В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.

### **Файл HEAD**

Файл HEAD - один из служебных файлов папки ```.git```. Он указывает на коммит, который сделан последним (то есть на самый новый).  
Если нужно передать последний коммит, то вместо его хеша можно просто написать ```HEAD``` — Git поймёт, что вы имели в виду последний коммит.

---

# **Создание удалённого репозитория на GitHub**

1. войдите в свой акк на GitHub и во вкладке *Repositories* нажмите на зеёлную кнопку **New** справа.
2. в окне создания нового репозитория назовите его и нажмите **Create repository**.  

Ура! вы создали удалённый репозиторий  
Осталось связать его с локальным - тем, что уже есть на компьютере.

---

# **Синхронизация репозиториев**

## **1. Генерация SSH-ключа**

1. откройте терминал и введите команду: ```ssh-keygen -t ed25519 -C "электронная почта, к которой привязан аккаунт на GitHub"``` ИЛИ команду ```ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан аккаунт на GitHub"```.
2. дважды нажмите **Enter **.  

Готово!  
Вызовите команду ```ls -a ~/.ssh```, чтобы проверить, сгенерировались ли ключи.  
На экране должны появиться два файла — один с расширением .pub, другой — без.  
Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами.  
**Файл без расширения .pub — приватный, им делиться нельзя!**


## **2. Связывание SSH-ключа и GitHub-аккаунта**

1. выведите содержимое файла **.pub** с помощью ```cat ~/.ssh/id_rsa.pub``` или ```cat ~/.ssh/id_ed25519.pub```.
2. скопируйте содержимое файла с публичным ключом (расширение **.pub**).
3. перейдите на GitHub и выберите пункт **Settings** в меню аккаунта.
4. в меню слева нажмите на пункт **SSH and GPG keys**, в открывшейся вкладке выберите **New SSH key**.
5. заполните окно **SSH-keys/Add new**: 
- в поле **Title** придумайте и впишите название ключа.
- в поле **Key type** должно быть **Authentication Key**.
- в поле **Key** скопируйте ваш ключ из буфера обмена.  
Нажмите на кнопку **Add SSH key**.
6. перейдите в консоль и проверьте правильность ключа с помощью команды ```ssh -T git@github.com```.  
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. 
7. введите **yes**, чтобы продолжить. появится приветствие на экране.  

Ура! ваш ключ привязан к GitHub!

## **3. Связывание локального и удалённого репозиториев**

1. перейдите на страницу удалённого репозитория на GitHub, выберите тип SSH и скопируйте URL.
2. откройте консоль, перейдите в каталог локального репозитория с помощью команды ```cd```.
3. введите команду ```git remote add origin <URL>```.
4. убедитесь, что всё работает, с помощью команды ```git remote -v```. В выводе вы должны увидеть две строчки c (fetch) и (push) на конце.  

Локальный и удалённый репозитории связаны! 

## **4. Синхронизация локального и удалённого репозиториев**

1. загрузите содержимое локального репозитория на GitHub с помощью команды ```git push -u origin main``` *(если команда приведёт к ошибке, попробуйте заменить main на master)*. 
2. зайдите в репозиторий на GitHub - в репозитории появились файлы с изменениями.  
В дальнейшем при работе с удалённым репозиторием флаг ```-u``` можно опустить и писать просто ```git push```.  

Ура! Локальный и удалённый репозитории синхронизированы!

